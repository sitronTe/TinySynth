/**
 * General TinySynth Heading.
 * We live in 16 bit signed 44100 Hz sound. 
 */
package synth;

import java.util.Hashtable;

import tools.SoundEvent;
import tools.SoundSourceFactory;

/**
 * The <code>BindByMarkSingleDrivenSource</code> is a thread safe implementation
 * of a {@link DrivenSource}. Bind by mark refers to mark defined in
 * {@link SoundEvent}. It plays sound from one single {@link SoundSource} at a
 * time. If a new <code>SoundEvent</code> is fired while it is playing sound
 * generated by a previous one, the new <code>SoundSource</code> replaces the
 * old. If channel count of the generated <code>SoundSource</code> is not equal
 * this <code>BindByMarkSingleDrivenSource</code> channel count, no sound will
 * be played.
 * 
 * @author Sitron Te
 * 
 * 
 */
public class BindByMarkSingleDrivenSource implements DrivenSource {
	private final int channelCount;
	private Hashtable<Integer, SoundSourceFactory> factories = new Hashtable<>();
	private SoundSource playing = null;

	/**
	 * Creates a new <code>BindByMarkSingleDrivenSource</code> with the
	 * specified number of output channels.
	 * 
	 * @param channelCount
	 *            number of output channels
	 * @throws IllegalArgumentException
	 *             if number of output channels is 0 or less.
	 */
	public BindByMarkSingleDrivenSource(int channelCount) {
		if (channelCount < 1)
			throw new IllegalArgumentException(
					"Must have at least one output channel!");
		this.channelCount = channelCount;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see synth.SoundSource#next()
	 */
	@Override
	public synchronized short[] next() {
		if (playing == null || !playing.hasNext())
			return new short[channelCount];
		return playing.next();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see synth.SoundSource#next(int)
	 */
	@Override
	public synchronized short[] next(int frames) {
		if (frames < 1)
			throw new IllegalArgumentException("Must ask for frames!");

		int samples = channelCount * frames;
		if (playing == null || !playing.hasNext())
			return new short[samples];
		short[] s = playing.next(frames);
		if (s.length == samples)
			return s;
		short[] ret = new short[samples];
		for (int i = 0; i < s.length; i++)
			ret[i] = s[i];
		return ret;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see synth.SoundSource#getChannelCount()
	 */
	@Override
	public int getChannelCount() {
		return channelCount;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see synth.SoundSource#reset()
	 */
	@Override
	public synchronized void reset() {
		factories.clear();
		playing = null;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see tools.SoundListener#fireSound(tools.SoundEvent)
	 */
	@Override
	public synchronized void fireSound(SoundEvent s) {
		Integer id = s.getEventMark();
		String d = s.getDescription();
		if (d == null) {
			if (factories.containsKey(id))
				playing = factories.get(id).getSoundSourceInstance();
			else
				playing = null;
		} else
			try {
				playing = factories.get(id).getSoundSourceInstance(d);
			} catch (UnsupportedOperationException e) {
				playing = factories.get(id).getSoundSourceInstance();
			}
		if (playing != null && playing.getChannelCount() != channelCount)
			playing = null;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see synth.DrivenSource#hasNext()
	 */
	@Override
	public boolean hasNext() {
		return true;
	}

	/**
	 * Binds a <code>SoundSourceFactory</code> to the event mark provided.
	 * 
	 * @param factory
	 *            factory to bind
	 * @param eventMark
	 *            the identifier for the factory
	 * @throws AlreadyBoundFactoryException
	 *             if this <code>BindByMarkSingleDrivenSource</code> has already
	 *             bound this event mark to a factory
	 * @throws IllegalArgumentException
	 *             if <code>eventMark == SoundEvent.ILLEGAL_EVENT_MARK</code>
	 */
	public synchronized void bindFactoryByMark(SoundSourceFactory factory,
			int eventMark) {
		if (eventMark == SoundEvent.ILLEGAL_EVENT_MARK)
			throw new IllegalArgumentException("Illegal event mark!");
		Integer id = eventMark;
		if (factories.containsKey(id))
			throw new AlreadyBoundFactoryException(
					"A SoundSourceFactory was already bound to this event mark!");
		factories.put(id, factory);
	}

}
